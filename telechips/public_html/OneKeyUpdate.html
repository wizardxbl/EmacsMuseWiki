<!DOCTYPE HTML>
<html>
<head>
<link rel="stylesheet" type="text/css" href="css/default-css.css" />
<script type="text/javascript">
function hide_area(sDivId) {
    var oDiv = document.getElementById(sDivId);
    oDiv.style.display = (oDiv.style.display=="none")?"block":"none";
}
</script>
</head>
<body>
    <div id="header">
      <h1 >One Key Updat</h1>
    </div>
<hr>
<p><a href="index.html">&lt;Back</a></p>

<p>New Partiton Table</p>

<hr />

<table class="muse-table" border="2" cellpadding="5">
  <tbody>
    <tr>
      <td>[Part  0. boot]</td>
      <td>[Start: 24]</td>
      <td>[Length: 5]</td>
    </tr>
    <tr>
      <td>[Part  1. kpanic]</td>
      <td>[Start: 29]</td>
      <td>[Length: 3]</td>
    </tr>
    <tr>
      <td>[Part  2. system]</td>
      <td>[Start: 32]</td>
      <td>[Length: 100]</td>
    </tr>
    <tr>
      <td>[Part  3. splash]</td>
      <td>[Start: 132]</td>
      <td>[Length: 2]</td>
    </tr>
    <tr>
      <td>[Part  4. cache]</td>
      <td>[Start: 134]</td>
      <td>[Length: 40]</td>
    </tr>
    <tr>
      <td>[Part  5. config]</td>
      <td>[Start: 174]</td>
      <td>[Length: 20]</td>
    </tr>
    <tr>
      <td>[Part  6. userdata]</td>
      <td>[Start: 194]</td>
      <td>[Length: 314]</td>
    </tr>
    <tr>
      <td>[Part  7. recovery]</td>
      <td>[Start: 508]</td>
      <td>[Length: 5]</td>
    </tr>
    <tr>
      <td>[Part  8. misc]</td>
      <td>[Start: 513]</td>
      <td>[Length: 1]</td>
    </tr>
    <tr>
      <td>[Part  9. tcc]</td>
      <td>[Start: 514]</td>
      <td>[Length: 1]</td>
    </tr>
    <tr>
      <td>[Part 10. encrypt]</td>
      <td>[Start: 515]</td>
      <td>[Length: 5]</td>
    </tr>
  </tbody>
</table>

<hr />

<table class="muse-table" border="2" cellpadding="5">
  <tbody>
    <tr>
      <td>boot</td>
      <td>StBlk: 24</td>
      <td>EndBlk: 28</td>
      <td>0x000000000000-0x000000a00000</td>
      <td>640K 160K</td>
    </tr>
    <tr>
      <td>kpanic</td>
      <td>StBlk: 29</td>
      <td>EndBlk: 31</td>
      <td>0x000000a00000-0x000001000000</td>
    </tr>
    <tr>
      <td>system</td>
      <td>StBlk: 32</td>
      <td>EndBlk: 131</td>
      <td>0x000001000000-0x00000d800000</td>
    </tr>
    <tr>
      <td>splash</td>
      <td>StBlk: 132</td>
      <td>EndBlk: 133</td>
      <td>0x00000d800000-0x00000dc00000</td>
    </tr>
    <tr>
      <td>cache</td>
      <td>StBlk: 134</td>
      <td>EndBlk: 173</td>
      <td>0x00000dc00000-0x000012c00000</td>
    </tr>
    <tr>
      <td>config</td>
      <td>StBlk: 174</td>
      <td>EndBlk: 193</td>
      <td>0x000012c00000-0x000015400000</td>
    </tr>
    <tr>
      <td>userdata</td>
      <td>StBlk: 194</td>
      <td>EndBlk: 507</td>
      <td>0x000015400000-0x00003c800000</td>
    </tr>
    <tr>
      <td>recovery</td>
      <td>StBlk: 508</td>
      <td>EndBlk: 512</td>
      <td>0x00003c800000-0x00003d200000</td>
    </tr>
    <tr>
      <td>misc</td>
      <td>StBlk: 513</td>
      <td>EndBlk: 513</td>
      <td>0x00003d200000-0x00003d400000</td>
    </tr>
    <tr>
      <td>tcc</td>
      <td>StBlk: 514</td>
      <td>EndBlk: 514</td>
      <td>0x00003d400000-0x00003d600000</td>
    </tr>
    <tr>
      <td>encrypt</td>
      <td>StBlk: 515</td>
      <td>EndBlk: 535</td>
      <td>0x00003d600000-0x00003e000000</td>
    </tr>
    <tr>
      <td>MTDTotalBlk:512</td>
      <td>MTDStBlk: 24</td>
      <td>MTDEndBlk: 536</td>
    </tr>
  </tbody>
</table>

<p>tcc_nand: blocksize 2097152 = 2048K = 2M</p>

<hr />

<h3>Android OTA 升级分析</h3>

<table class="image" width="100%">
  <tr><td align="center"><img src="images/Android升级流程.png" alt="Android升级系统流程" /></td></tr>
  <tr><td align="center" class="image-caption">Android升级系统流程</td></tr>
</table>

<p>编译整个SDK的时候，参考build/core/Makefile文件</p>

<pre class="example">
# Depending on the various images guarantees that the underlying
# directories are up-to-date.
$(BUILT_TARGET_FILES_PACKAGE): \
		$(INSTALLED_BOOTIMAGE_TARGET) \
		$(INSTALLED_RADIOIMAGE_TARGET) \
		$(INSTALLED_RECOVERYIMAGE_TARGET) \
		$(INSTALLED_SYSTEMIMAGE) \
		$(INSTALLED_USERDATAIMAGE_TARGET) \
		$(INSTALLED_ANDROID_INFO_TXT_TARGET) \
		$(built_ota_tools) \
		$(APKCERTS_FILE) \
		$(HOST_OUT_EXECUTABLES)/fs_config \
		| $(ACP)
	@echo &quot;Package target files: $@&quot;
	$(hide) rm -rf $@ $(zip_root)
	$(hide) mkdir -p $(dir $@) $(zip_root) 建立了一个目录
	@# Components of the recovery image recovery image的组件们
	$(hide) mkdir -p $(zip_root)/RECOVERY 再刚才建立的目录下面建立一个RECOVERY的目录
	$(hide) $(call package_files-copy-root, \
		$(TARGET_RECOVERY_ROOT_OUT),$(zip_root)/RECOVERY/RAMDISK)
ifdef INSTALLED_KERNEL_TARGET
	$(hide) $(ACP) $(INSTALLED_KERNEL_TARGET) $(zip_root)/RECOVERY/kernel
endif
ifdef INSTALLED_2NDBOOTLOADER_TARGET
	$(hide) $(ACP) \
		$(INSTALLED_2NDBOOTLOADER_TARGET) $(zip_root)/RECOVERY/second
endif
ifdef BOARD_KERNEL_CMDLINE
	$(hide) echo &quot;$(BOARD_KERNEL_CMDLINE)&quot; &gt; $(zip_root)/RECOVERY/cmdline
endif
ifdef BOARD_KERNEL_BASE
	$(hide) echo &quot;$(BOARD_KERNEL_BASE)&quot; &gt; $(zip_root)/RECOVERY/base
endif
ifdef BOARD_KERNEL_PAGESIZE
	$(hide) echo &quot;$(BOARD_KERNEL_PAGESIZE)&quot; &gt; $(zip_root)/RECOVERY/pagesize
endif
填充RECOVERY子目录的内容 用于生成recovery.img，包括kernel的image，recovery根文件系统的image
	@# Components of the boot image
	$(hide) mkdir -p $(zip_root)/BOOT
	$(hide) $(call package_files-copy-root, \
		$(TARGET_ROOT_OUT),$(zip_root)/BOOT/RAMDISK)
ifdef INSTALLED_KERNEL_TARGET
	$(hide) $(ACP) $(INSTALLED_KERNEL_TARGET) $(zip_root)/BOOT/kernel
endif
ifdef INSTALLED_2NDBOOTLOADER_TARGET
	$(hide) $(ACP) \
		$(INSTALLED_2NDBOOTLOADER_TARGET) $(zip_root)/BOOT/second
endif
ifdef BOARD_KERNEL_CMDLINE
	$(hide) echo &quot;$(BOARD_KERNEL_CMDLINE)&quot; &gt; $(zip_root)/BOOT/cmdline
endif
ifdef BOARD_KERNEL_BASE
	$(hide) echo &quot;$(BOARD_KERNEL_BASE)&quot; &gt; $(zip_root)/BOOT/base
endif
ifdef BOARD_KERNEL_PAGESIZE
	$(hide) echo &quot;$(BOARD_KERNEL_PAGESIZE)&quot; &gt; $(zip_root)/BOOT/pagesize
endif
	$(hide) $(foreach t,$(INSTALLED_RADIOIMAGE_TARGET),\
	            mkdir -p $(zip_root)/RADIO; \
	            $(ACP) $(t) $(zip_root)/RADIO/$(notdir $(t));)
填充BOOT子目录的内容 用于生成boot.img，和RECOVERY目录类似，包括kernel的image，根文件系统的image
	@# Contents of the system image
	$(hide) $(call package_files-copy-root, \
		$(SYSTEMIMAGE_SOURCE_DIR),$(zip_root)/SYSTEM)
填充SYSTEM子目录的内容 这是升级的主要内容
	@# Contents of the data image
	$(hide) $(call package_files-copy-root, \
		$(TARGET_OUT_DATA),$(zip_root)/DATA)
填充DATA子目录的内容
	@# Extra contents of the OTA package
	$(hide) mkdir -p $(zip_root)/OTA/bin
	$(hide) $(ACP) $(INSTALLED_ANDROID_INFO_TXT_TARGET) $(zip_root)/OTA/
	$(hide) $(ACP) $(PRIVATE_OTA_TOOLS) $(zip_root)/OTA/bin/
填充OTA/bin子目录的内容 是OTA升级自己使用的程序
	@# Files that do not end up in any images, but are necessary to
	@# build them.
	$(hide) mkdir -p $(zip_root)/META
	$(hide) $(ACP) $(APKCERTS_FILE) $(zip_root)/META/apkcerts.txt
	$(hide)	echo &quot;$(PRODUCT_OTA_PUBLIC_KEYS)&quot; &gt; $(zip_root)/META/otakeys.txt
	$(hide) echo &quot;recovery_api_version=$(PRIVATE_RECOVERY_API_VERSION)&quot; &gt; $(zip_root)/META/misc_info.txt
ifdef BOARD_FLASH_BLOCK_SIZE
	$(hide) echo &quot;blocksize=$(BOARD_FLASH_BLOCK_SIZE)&quot; &gt;&gt; $(zip_root)/META/misc_info.txt
endif
ifdef BOARD_BOOTIMAGE_PARTITION_SIZE
	$(hide) echo &quot;boot_size=$(BOARD_BOOTIMAGE_PARTITION_SIZE)&quot; &gt;&gt; $(zip_root)/META/misc_info.txt
endif
ifdef BOARD_RECOVERYIMAGE_PARTITION_SIZE
	$(hide) echo &quot;recovery_size=$(BOARD_RECOVERYIMAGE_PARTITION_SIZE)&quot; &gt;&gt; $(zip_root)/META/misc_info.txt
endif
ifdef BOARD_SYSTEMIMAGE_PARTITION_SIZE
	$(hide) echo &quot;system_size=$(BOARD_SYSTEMIMAGE_PARTITION_SIZE)&quot; &gt;&gt; $(zip_root)/META/misc_info.txt
endif
ifdef BOARD_USERDATAIMAGE_PARTITION_SIZE
	$(hide) echo &quot;userdata_size=$(BOARD_USERDATAIMAGE_PARTITION_SIZE)&quot; &gt;&gt; $(zip_root)/META/misc_info.txt
endif
	$(hide) echo &quot;tool_extensions=$(tool_extensions)&quot; &gt;&gt; $(zip_root)/META/misc_info.txt
ifdef mkyaffs2_extra_flags
	$(hide) echo &quot;mkyaffs2_extra_flags=$(mkyaffs2_extra_flags)&quot; &gt;&gt; $(zip_root)/META/misc_info.txt
endif
填充META子目录的内容，这里包含了OTA脚本需要的一些附加信息
	@# Zip everything up, preserving symlinks
	$(hide) (cd $(zip_root) &amp;&amp; zip -qry ../$(notdir $@) .)
将所有内容打包，供下一阶段使用
	@# Run fs_config on all the system files in the zip, and save the output
	$(hide) zipinfo -1 $@ | awk -F/ 'BEGIN { OFS=&quot;/&quot; } /^SYSTEM\// {$$1 = &quot;system&quot;; print}' | $(HOST_OUT_EXECUTABLES)/fs_config &gt; $(zip_root)/META/filesystem_config.txt
	$(hide) (cd $(zip_root) &amp;&amp; zip -q ../$(notdir $@) META/filesystem_config.txt)
生成META/filesystem_config.txt并将其加入到zip包中，该文件保存了system目录下各目录，文件的权限及owner
</pre>

<h4>这里强调一点 关于目录的事情</h4>

<p class="first">刚才说了那么多的目录，我是真心不知道这些目录在哪里，因为整个Make过程变量实在是太多了，除非记录所有信息，然后慢慢分析</p>

<p>不过呢，我在out目录下面find ./ -name了一下filesystem_config.txt文件，于是找到了目录路径</p>

<pre class="example">
out/target/product/{board}/obj/PACKAGING/target_files_intermediates/
</pre>

<p>这个目录下面会看到每次编译出来的文件夹和压缩包</p>

<p>我们可以进到最近编译的full_{board}_target_files-eng.{people name}.{YYYYMMDD}.{HHMMSS}/目录下</p>

<p>然后，就会看到BOOT,DATA,META,OTA,RECOVERY,SYSTEM这几个目录了</p>

<p>下面关注一下这几个目录里面的内容</p>

<p><a name="DIR" id="DIR"></a>
<a href="OneKeyUpdate.html#BOOT">BOOT</a>
<a href="OneKeyUpdate.html#DATA">DATA</a>
<a href="OneKeyUpdate.html#META">META</a>
<a href="OneKeyUpdate.html#OTA">OTA</a>
<a href="OneKeyUpdate.html#RECOVERY">RECOVERY</a>
<a href="OneKeyUpdate.html#SYSTEM">SYSTEM</a></p>

<p><a name="BOOT" id="BOOT"></a>
BOOT</p>

<pre class="example">
.
├── base
├── cmdline
├── kernel
├── pagesize
└── RAMDISK
    ├── data
    ├── default.prop
    ├── dev
    ├── init
    ├── init.goldfish.rc
    ├── initlogo.rle
    ├── init.m801_88.rc
    ├── init.rc
    ├── lib
    │   └── modules
    │       ├── ehci-hcd.ko
    │       ├── ohci-hcd.ko
    │       ├── tcc_init_nand.ko
    │       ├── tcc_mtd.ko
    │       ├── tcc_nand.ko
    │       ├── tcc_ndd.ko
    │       └── ufsd.ko
    ├── proc
    ├── sbin
    │   ├── adbd
    │   └── ueventd -&gt; ../init
    ├── sys
    ├── system
    ├── ueventd.goldfish.rc
    ├── ueventd.m801_88.rc
    └── ueventd.rc

9 directories, 22 files
</pre>
<a href="OneKeyUpdate.html#DIR">top</a>

<p><a name="DATA" id="DATA"></a>
DATA</p>

<pre class="example">
.
└── app
    ├── ApiDemos.apk
    ├── test_algorithm_host
    ├── test_char_traits_host
    ├── test_functional_host
    ├── test_iomanip_host
    ├── test_ios_base_host
    ├── test_ios_pos_types_host
    ├── test_iostream_host
    ├── test_iterator_host
    ├── test_limits_host
    ├── test_list_host
    ├── test_memory_host
    ├── test_set_host
    ├── test_sstream_host
    ├── test_streambuf_host
    ├── test_string_host
    ├── test_type_traits_host
    ├── test_uninitialized_host
    └── test_vector_host

1 directory, 19 files
</pre>
<a href="OneKeyUpdate.html#DIR">top</a>

<p><a name="META" id="META"></a>
META</p>

<pre class="example">
.
├── apkcerts.txt
├── filesystem_config.txt
├── misc_info.txt
└── otakeys.txt

0 directories, 4 files
</pre>
<a href="OneKeyUpdate.html#DIR">top</a>

<p><a name="OTA" id="OTA"></a>
OTA</p>

<pre class="example">
.
├── android-info.txt
└── bin
    ├── applypatch
    ├── applypatch_static
    ├── check_prereq
    └── updater

1 directory, 5 files
</pre>
<a href="OneKeyUpdate.html#DIR">top</a>

<p><a name="RECOVERY" id="RECOVERY"></a>
RECOVERY</p>

<pre class="example">
.
├── base
├── cmdline
├── kernel
├── pagesize
└── RAMDISK
    ├── data
    ├── default.prop
    ├── dev
    ├── etc
    │   └── recovery.fstab
    ├── init
    ├── initlogo.rle
    ├── init.m801_88.rc
    ├── init.rc
    ├── lib
    │   └── modules
    │       ├── ehci-hcd.ko
    │       ├── ohci-hcd.ko
    │       ├── tcc_init_nand.ko
    │       ├── tcc_mtd.ko
    │       ├── tcc_nand.ko
    │       ├── tcc_ndd.ko
    │       └── ufsd.ko
    ├── proc
    ├── res
    │   ├── images
    │   │   ├── icon_error.png
    │   │   ├── icon_installing.png
    │   │   ├── indeterminate1.png
    │   │   ├── indeterminate2.png
    │   │   ├── indeterminate3.png
    │   │   ├── indeterminate4.png
    │   │   ├── indeterminate5.png
    │   │   ├── indeterminate6.png
    │   │   ├── progress_empty.png
    │   │   └── progress_fill.png
    │   └── keys
    ├── sbin
    │   ├── adbd
    │   ├── recovery
    │   └── ueventd -&gt; ../init
    ├── sys
    ├── system
    ├── tmp
    ├── ueventd.goldfish.rc
    ├── ueventd.m801_88.rc
    └── ueventd.rc

13 directories, 34 files
</pre>
<a href="OneKeyUpdate.html#DIR">top</a>

<p><a name="SYSTEM" id="SYSTEM"></a>
SYSTEM 这里的文件要多一些</p>

<pre class="example">
.
├── app
│   ├── AccountAndSyncSettings.apk
│   ├── ApplicationsProvider.apk
│   ├── Bluetooth.apk
│   ├── Browser.apk
│   ├── Calculator.apk
│   ├── Calendar.apk
│   ├── CalendarProvider.apk
│   ├── Camera.apk
│   ├── CertInstaller.apk
│   ├── Contacts.apk
│   ├── ContactsProvider.apk
│   ├── CustomLocale.apk
│   ├── DefaultContainerService.apk
│   ├── DeskClock.apk
│   ├── Development.apk
│   ├── DownloadProvider.apk
│   ├── DownloadProviderUi.apk
│   ├── DrmProvider.apk
│   ├── Email.apk
│   ├── Gallery3D.apk
│   ├── HTMLViewer.apk
│   ├── LatinIME.apk
│   ├── Launcher2.apk
│   ├── LiveWallpapers.apk
│   ├── LiveWallpapersPicker.apk
│   ├── MagicSmokeWallpapers.apk
│   ├── MediaProvider.apk
│   ├── Mms.apk
│   ├── Music.apk
│   ├── OpenWnn.apk
│   ├── PackageInstaller.apk
│   ├── Phone.apk
│   ├── PicoTts.apk
│   ├── PinyinIME.apk
│   ├── Protips.apk
│   ├── Provision.apk
│   ├── QuickSearchBox.apk
│   ├── SampleDVBTPlayer.apk
│   ├── SampleISDBTPlayer.apk
│   ├── SampleTDMBPlayer.apk
│   ├── Settings.apk
│   ├── SettingsProvider.apk
│   ├── SoundRecorder.apk
│   ├── SpareParts.apk
│   ├── SpeechRecorder.apk
│   ├── SystemUI.apk
│   ├── TelechipsAudioEffect.apk
│   ├── TelechipsSettings.apk
│   ├── TelechipsSystemUpdater.apk
│   ├── TelephonyProvider.apk
│   ├── Term.apk
│   ├── TSCalibration.apk
│   ├── TtsService.apk
│   ├── UserDictionaryProvider.apk
│   ├── VisualizationWallpapers.apk
│   ├── VoiceDialer.apk
│   └── VpnServices.apk
├── atheros
│   └── 1020200
│       ├── PS_ASIC.pst
│       └── RamPatch.txt
├── bin
│   ├── abtfilt
│   ├── akmd8975
│   ├── alsa_amixer
│   ├── alsa_aplay
│   ├── alsa_ctl
│   ├── am
│   ├── applypatch
│   ├── applypatch_static
│   ├── app_process
│   ├── audioloop
│   ├── bccmd
│   ├── bluetoothd
│   ├── bmgr
│   ├── bootanimation
│   ├── bugreport
│   ├── busybox
│   ├── cat -&gt; toolbox
│   ├── check_prereq
│   ├── chkntfs
│   ├── chmod -&gt; toolbox
│   ├── chown -&gt; toolbox
│   ├── cmp -&gt; toolbox
│   ├── cp -&gt; busybox
│   ├── dalvikvm
│   ├── date -&gt; toolbox
│   ├── dbus-daemon
│   ├── dd -&gt; toolbox
│   ├── debuggerd
│   ├── dexopt
│   ├── df -&gt; toolbox
│   ├── dhcpcd
│   ├── dmesg -&gt; toolbox
│   ├── dnsmasq
│   ├── drvdebugctrl
│   ├── dumpstate
│   ├── dumpsys
│   ├── dvbtdump
│   ├── dvz
│   ├── flash_eraseall
│   ├── flash_image
│   ├── fsck_msdos
│   ├── gdbjithelper
│   ├── gdbserver
│   ├── getevent -&gt; toolbox
│   ├── getprop -&gt; toolbox
│   ├── grep -&gt; busybox
│   ├── gzip
│   ├── hciattach
│   ├── hd -&gt; toolbox
│   ├── hostapd
│   ├── hostapd_cli
│   ├── hostapd_wps
│   ├── id -&gt; toolbox
│   ├── ifconfig -&gt; toolbox
│   ├── iftop -&gt; toolbox
│   ├── ime
│   ├── input
│   ├── InputChannel_test
│   ├── InputDispatcher_test
│   ├── InputPublisherAndConsumer_test
│   ├── InputReader_test
│   ├── insmod -&gt; toolbox
│   ├── installd
│   ├── ioctl -&gt; toolbox
│   ├── ionice -&gt; toolbox
│   ├── iptables
│   ├── iwconfig
│   ├── iwlist
│   ├── keystore
│   ├── keystore_cli
│   ├── kill -&gt; toolbox
│   ├── linker
│   ├── ln -&gt; toolbox
│   ├── log -&gt; toolbox
│   ├── logcat
│   ├── logwrapper
│   ├── Looper_test
│   ├── ls -&gt; toolbox
│   ├── lsmod -&gt; toolbox
│   ├── lsof -&gt; toolbox
│   ├── mediaserver
│   ├── mem
│   ├── mkdir -&gt; toolbox
│   ├── mkntfs
│   ├── monkey
│   ├── mount -&gt; toolbox
│   ├── mtpd
│   ├── mv -&gt; toolbox
│   ├── nandread -&gt; toolbox
│   ├── ndc
│   ├── netcfg
│   ├── netd
│   ├── netstat -&gt; toolbox
│   ├── newfs_msdos -&gt; toolbox
│   ├── notify -&gt; toolbox
│   ├── ObbFile_test
│   ├── omx_tests
│   ├── pand
│   ├── ping
│   ├── pm
│   ├── pppd
│   ├── printenv -&gt; toolbox
│   ├── ps -&gt; toolbox
│   ├── qemud
│   ├── qemu-props
│   ├── racoon
│   ├── radiooptions
│   ├── reboot -&gt; toolbox
│   ├── recEvent
│   ├── record
│   ├── recovery
│   ├── remote_player_service
│   ├── renice -&gt; toolbox
│   ├── rild
│   ├── rm -&gt; toolbox
│   ├── rmdir -&gt; toolbox
│   ├── rmmod -&gt; toolbox
│   ├── route -&gt; toolbox
│   ├── rtp_test
│   ├── run-as
│   ├── schedtest
│   ├── schedtop -&gt; toolbox
│   ├── sdcard
│   ├── sdptool
│   ├── sendevent -&gt; toolbox
│   ├── service
│   ├── servicemanager
│   ├── setconsole -&gt; toolbox
│   ├── setprop -&gt; toolbox
│   ├── setup_dvbt.sh
│   ├── setup_dxb.sh
│   ├── setup_iptv_ip.sh
│   ├── setup_iptv.sh
│   ├── setup_tdmb.sh
│   ├── sh
│   ├── showlease
│   ├── skia_test
│   ├── sleep -&gt; toolbox
│   ├── smd -&gt; toolbox
│   ├── stagefright
│   ├── start -&gt; toolbox
│   ├── stop -&gt; toolbox
│   ├── String8_test
│   ├── surfaceflinger
│   ├── svc
│   ├── sync -&gt; toolbox
│   ├── system_server
│   ├── tar -&gt; busybox
│   ├── tc
│   ├── tcc_dxb_service
│   ├── tdmbdump
│   ├── testid3
│   ├── toolbox
│   ├── top -&gt; toolbox
│   ├── umount -&gt; toolbox
│   ├── unzip -&gt; busybox
│   ├── updater
│   ├── uptime -&gt; toolbox
│   ├── vdc
│   ├── vi -&gt; busybox
│   ├── vmstat -&gt; toolbox
│   ├── vold
│   ├── watchprops -&gt; toolbox
│   ├── wipe -&gt; toolbox
│   ├── wlan_tool
│   ├── wmiconfig
│   ├── wpa_cli
│   └── wpa_supplicant
├── build.prop
├── etc
│   ├── apns-conf.xml
│   ├── asound.conf
│   ├── bluetooth
│   │   ├── audio.conf
│   │   ├── auto_pairing.conf
│   │   ├── blacklist.conf
│   │   ├── input.conf
│   │   └── main.conf
│   ├── dbus.conf
│   ├── dhcpcd
│   │   ├── dhcpcd.conf
│   │   ├── dhcpcd-hooks
│   │   │   ├── 20-dns.conf
│   │   │   └── 95-configured
│   │   └── dhcpcd-run-hooks
│   ├── event-log-tags
│   ├── hosts
│   ├── init.goldfish.sh
│   ├── media_profiles.xml
│   ├── NOTICE.html.gz
│   ├── permissions
│   │   ├── android.hardware.camera.flash-autofocus.xml
│   │   ├── android.hardware.camera.front.xml
│   │   ├── android.hardware.location.gps.xml
│   │   ├── android.hardware.touchscreen.multitouch.jazzhand.xml
│   │   ├── android.hardware.wifi.xml
│   │   ├── android.serialport.xml
│   │   ├── android.software.live_wallpaper.xml
│   │   ├── android.software.sip.voip.xml
│   │   ├── com.android.location.provider.xml
│   │   ├── com.telechips.android.atsc.xml
│   │   ├── com.telechips.android.dvbt.xml
│   │   ├── com.telechips.android.iptv.xml
│   │   ├── com.telechips.android.isdbt.xml
│   │   ├── com.telechips.android.tdmb.xml
│   │   ├── handheld_core_hardware.xml
│   │   └── platform.xml
│   ├── ppp
│   │   └── ip-up-vpn
│   ├── security
│   │   ├── cacerts.bks
│   │   └── otacerts.zip
│   ├── vold.conf
│   ├── vold.fstab
│   └── wifi
│       ├── hostapd.conf
│       └── wpa_supplicant.conf
├── fonts
│   ├── Clockopia.ttf
│   ├── DroidSansArabic.ttf
│   ├── DroidSans-Bold.ttf
│   ├── DroidSansFallback_DxB.ttf
│   ├── DroidSansFallback.ttf
│   ├── DroidSansHebrew.ttf
│   ├── DroidSansMono.ttf
│   ├── DroidSansThai.ttf
│   ├── DroidSans.ttf
│   ├── DroidSerif-BoldItalic.ttf
│   ├── DroidSerif-Bold.ttf
│   ├── DroidSerif-Italic.ttf
│   ├── DroidSerif-Regular.ttf
│   └── HMFMOLD_18.bdf
├── framework
│   ├── am.jar
│   ├── android.policy.jar
│   ├── android.serialport.jar
│   ├── android.test.runner.jar
│   ├── bmgr.jar
│   ├── bouncycastle.jar
│   ├── com.android.location.provider.jar
│   ├── com.telechips.android.atsc.jar
│   ├── com.telechips.android.dvbt.jar
│   ├── com.telechips.android.iptv.jar
│   ├── com.telechips.android.isdbt.jar
│   ├── com.telechips.android.tdmb.jar
│   ├── core.jar
│   ├── core-junit.jar
│   ├── ext.jar
│   ├── framework.jar
│   ├── framework-res.apk
│   ├── ime.jar
│   ├── input.jar
│   ├── javax.obex.jar
│   ├── monkey.jar
│   ├── pm.jar
│   ├── services.jar
│   ├── sqlite-jdbc.jar
│   └── svc.jar
├── key_3000000.psr
├── key_921600.psr
├── lib
│   ├── bluez-plugin
│   │   ├── audio.so
│   │   └── input.so
│   ├── dejitter.so
│   ├── egl
│   │   ├── egl.cfg
│   │   ├── libEGL_mali.so
│   │   ├── libGLES_android.so
│   │   ├── libGLESv1_CM_mali.so
│   │   └── libGLESv2_mali.so
│   ├── hw
│   │   ├── acoustics.default.so
│   │   ├── alsa.default.so
│   │   ├── gps.goldfish.so
│   │   ├── gralloc.default.so
│   │   ├── gralloc.tcc88xx.so
│   │   ├── lights.tcc88xx.so
│   │   ├── overlay.tcc88xx.so
│   │   ├── sensors.goldfish.so
│   │   └── sensors.tcc88xx.so
│   ├── inputraw.so
│   ├── invoke_mock_media_player.so
│   ├── liba2dp.so
│   ├── libacc.so
│   ├── libandroid_runtime.so
│   ├── libandroid_servers.so
│   ├── libandroid.so
│   ├── libasound.so
│   ├── libatsc_jni.so
│   ├── libatsc.so
│   ├── libaudioeffect_jni.so
│   ├── libaudioflinger.so
│   ├── libaudiopolicy.so
│   ├── libaudio.so
│   ├── libbinder.so
│   ├── libbluedroid.so
│   ├── libbluetoothd.so
│   ├── libbluetooth.so
│   ├── libcamera_client.so
│   ├── libcameraservice.so
│   ├── libcamera.so
│   ├── libc_malloc_debug_leak.so
│   ├── libc_malloc_debug_qemu.so
│   ├── libcrypto.so
│   ├── libc.so
│   ├── libctest.so
│   ├── libcutils.so
│   ├── libdbus.so
│   ├── libdiskconfig.so
│   ├── libdl.so
│   ├── libdrm1_jni.so
│   ├── libdrm1.so
│   ├── lib.DVBDemux.Input.so
│   ├── libdvbt_jni.so
│   ├── libdvbt.so
│   ├── libdvm.so
│   ├── libdxbfont.so
│   ├── libdxbsc.so
│   ├── libdxbutils.so
│   ├── libeffects.so
│   ├── libEGL.so
│   ├── libemoji.so
│   ├── libETC1.so
│   ├── libexif.so
│   ├── libexpat.so
│   ├── libextenddisplay.so
│   ├── libFFTEm.so
│   ├── libGLESv1_CM.so
│   ├── libGLESv2.so
│   ├── libgui.so
│   ├── libhardware_legacy.so
│   ├── libhardware.so
│   ├── libhdmi.so
│   ├── libhostapd_client.so
│   ├── libicui18n.so
│   ├── libicuuc.so
│   ├── libiprouteutil.so
│   ├── libiptv_jni.so
│   ├── libiptv.so
│   ├── libISDBTDemux.Input.so
│   ├── libisdbt_jni.so
│   ├── libisdbt.so
│   ├── libjnigraphics.so
│   ├── libjni_latinime.so
│   ├── libjni_pinyinime.so
│   ├── libjpeg.so
│   ├── liblog.so
│   ├── libMali.so
│   ├── libmedia_jni.so
│   ├── libmediaplayerservice.so
│   ├── libmedia.so
│   ├── libmediastreamer2.so
│   ├── libmock_ril.so
│   ├── libm.so
│   ├── libmtdutils1.so
│   ├── libnativehelper.so
│   ├── libnetlink.so
│   ├── libnetutils.so
│   ├── libnfc_ndef.so
│   ├── libOMX.TCC.aacdec.so
│   ├── libOMX.TCC.aacenc.so
│   ├── libOMX.TCC.alsasink.so
│   ├── libOMX.TCC.apedec.so
│   ├── libOMX.TCC.ATSCDemux.so
│   ├── libOMX.TCC.ATSCTuner.so
│   ├── libOMX.TCC.audio.so
│   ├── libOMX.TCC.base.so
│   ├── libOMX.TCC.bsacdec.so
│   ├── libOMX.TCC.DVBDemux.so
│   ├── libOMX.TCC.DVBTTuner.so
│   ├── libOMX.TCC.DxB.AudioDec.so
│   ├── libOMX.TCC.DxB.base.so
│   ├── libOMX.TCC.DxB.VideoDec.so
│   ├── libOMX.TCC.DxB.VPUDec.so
│   ├── libOMX.TCC.fbdevsink.so
│   ├── libOMX.TCC.flacdec.so
│   ├── libOMX.TCC.IPTVDemux.so
│   ├── libOMX.TCC.ISDBTDemux.so
│   ├── libOMX.TCC.ISDBTTuner.so
│   ├── libOMX.TCC.mp2dec.so
│   ├── libOMX.TCC.mp3dec.so
│   ├── libOMX.TCC.mp3enc.so
│   ├── libOMX.TCC.MTV818.Tuner.so
│   ├── libOMX.TCC.NMI32X.Tuner.so
│   ├── libOMX.TCC.PADParser.so
│   ├── libOMX.TCC.pcmdec.so
│   ├── libOMX.TCC.spdif.so
│   ├── libOMX.TCC.TCC351X.Tuner.so
│   ├── libOMX.TCC.tdmbdemux.so
│   ├── libOMX.TCC.tdmbrec.so
│   ├── libOMX.TCC.tdmbtuner.so
│   ├── libOMX.TCC.Toshiba.Tuner.so
│   ├── libOMX.TCC.Tuner.interface.so
│   ├── libOMX.TCC.VideoDec.so
│   ├── libOMX.TCC.VideoEnc.so
│   ├── libOMX.TCC.vorbisdec.so
│   ├── libOMX.TCC.VPUDec.so
│   ├── libOMX.TCC.VPUEnc.so
│   ├── libOMX.TCC.wmadec.so
│   ├── libOpenSLES.so
│   ├── libortp.so
│   ├── libpagemap.so
│   ├── libpixelflinger.so
│   ├── libpmap.so
│   ├── libreference-cdma-sms.so
│   ├── libreference-ril.so
│   ├── libril.so
│   ├── librs_jni.so
│   ├── libRS.so
│   ├── librtp_jni.so
│   ├── libsensorservice.so
│   ├── libserial_port.so
│   ├── libskiagl.so
│   ├── libskia.so
│   ├── libsonivox.so
│   ├── libsoundpool.so
│   ├── libspdifsound.so
│   ├── libsqlite_jni.so
│   ├── libsqlite.so
│   ├── libSR_AudioIn.so
│   ├── libsrec_jni.so
│   ├── libssl.so
│   ├── libstagefright_amrnb_common.so
│   ├── libstagefright_avc_common.so
│   ├── libstagefright_color_conversion.so
│   ├── libstagefright_enc_common.so
│   ├── libstagefright_foundation.so
│   ├── libstagefrighthw.so
│   ├── libstagefright_omx.so
│   ├── libstagefright.so
│   ├── libstdc++.so
│   ├── libstlport.so
│   ├── libsurfaceflinger_client.so
│   ├── libsurfaceflinger.so
│   ├── libsystem_server.so
│   ├── libsysutils.so
│   ├── libTCC_CDK_AUDIO.so
│   ├── libTCC_CDK_CONFIG.so
│   ├── libTCC_CDK_DXB_LIB.so
│   ├── libTCC_CDK_LIB.so
│   ├── libTCC_CDK_WRAPPER.so
│   ├── libTCC_Decoder.so
│   ├── libTCCDxBInterface.so
│   ├── libtccdxbspdifparser.so
│   ├── libTCC_Encoder.so
│   ├── libTCCInterSubtitle.so
│   ├── libTCC_OMXCore.so
│   ├── libTCCRemotePlayerClient.so
│   ├── libTCCsubtitle.so
│   ├── libtdmb_jni.so
│   ├── libtdmb.so
│   ├── libterm.so
│   ├── libthread_db.so
│   ├── libtslib.so
│   ├── libttspico.so
│   ├── libttssynthproxy.so
│   ├── libui.so
│   ├── libUMP.so
│   ├── libutils.so
│   ├── libvorbisidec.so
│   ├── libwebcore.so
│   ├── libwnndict.so
│   ├── libWnnEngDic.so
│   ├── libWnnJpnDic.so
│   ├── libwpa_client.so
│   ├── libz.so
│   ├── linear.so
│   ├── modules
│   │   ├── vpu_decoder_ext.ko
│   │   ├── vpu_decoder.ko
│   │   ├── vpu_encoder.ko
│   │   └── vpu_manager.ko
│   ├── pthres.so
│   └── soundfx
│       ├── libbundlewrapper.so
│       ├── libreverbwrapper.so
│       ├── libtcc_soundeffect.so
│       └── libvisualizer.so
├── media
│   └── audio
│       ├── alarms
│       │   ├── Alarm_Beep_01.ogg
│       │   ├── Alarm_Beep_02.ogg
│       │   ├── Alarm_Beep_03.ogg
│       │   ├── Alarm_Buzzer.ogg
│       │   ├── Alarm_Classic.ogg
│       │   └── Alarm_Rooster_02.ogg
│       ├── notifications
│       │   ├── Beat_Box_Android.ogg
│       │   ├── CaffeineSnake.ogg
│       │   ├── DearDeer.ogg
│       │   ├── DontPanic.ogg
│       │   ├── F1_MissedCall.ogg
│       │   ├── F1_New_MMS.ogg
│       │   ├── F1_New_SMS.ogg
│       │   ├── Heaven.ogg
│       │   ├── Highwire.ogg
│       │   ├── KzurbSonar.ogg
│       │   ├── OnTheHunt.ogg
│       │   ├── TaDa.ogg
│       │   ├── Tinkerbell.ogg
│       │   └── Voila.ogg
│       ├── ringtones
│       │   ├── BeatPlucker.ogg
│       │   ├── BentleyDubs.ogg
│       │   ├── BirdLoop.ogg
│       │   ├── CaribbeanIce.ogg
│       │   ├── CrazyDream.ogg
│       │   ├── CurveBall.ogg
│       │   ├── DreamTheme.ogg
│       │   ├── EtherShake.ogg
│       │   ├── FriendlyGhost.ogg
│       │   ├── GameOverGuitar.ogg
│       │   ├── Growl.ogg
│       │   ├── InsertCoin.ogg
│       │   ├── LoopyLounge.ogg
│       │   ├── LoveFlute.ogg
│       │   ├── MidEvilJaunt.ogg
│       │   ├── MildlyAlarming.ogg
│       │   ├── NewPlayer.ogg
│       │   ├── Noises1.ogg
│       │   ├── Noises2.ogg
│       │   ├── Noises3.ogg
│       │   ├── OrganDub.ogg
│       │   ├── Ring_Classic_02.ogg
│       │   ├── Ring_Digital_02.ogg
│       │   ├── Ring_Synth_02.ogg
│       │   ├── Ring_Synth_04.ogg
│       │   ├── RomancingTheTone.ogg
│       │   ├── SitarVsSitar.ogg
│       │   ├── SpringyJalopy.ogg
│       │   ├── Terminated.ogg
│       │   ├── TwirlAway.ogg
│       │   ├── VeryAlarmed.ogg
│       │   └── World.ogg
│       └── ui
│           ├── camera_click.ogg
│           ├── Effect_Tick.ogg
│           ├── KeypressDelete.ogg
│           ├── KeypressReturn.ogg
│           ├── KeypressSpacebar.ogg
│           ├── KeypressStandard.ogg
│           ├── Lock.ogg
│           ├── Unlock.ogg
│           └── VideoRecord.ogg
├── ts.conf
├── tts
│   └── lang_pico
│       ├── de-DE_gl0_sg.bin
│       ├── de-DE_ta.bin
│       ├── en-GB_kh0_sg.bin
│       ├── en-GB_ta.bin
│       ├── en-US_lh0_sg.bin
│       ├── en-US_ta.bin
│       ├── es-ES_ta.bin
│       ├── es-ES_zl0_sg.bin
│       ├── fr-FR_nk0_sg.bin
│       ├── fr-FR_ta.bin
│       ├── it-IT_cm0_sg.bin
│       └── it-IT_ta.bin
├── usr
│   ├── icu
│   │   └── icudt44l.dat
│   ├── keychars
│   │   ├── m801_88-gpiokey.kcm.bin
│   │   ├── qwerty2.kcm.bin
│   │   └── qwerty.kcm.bin
│   ├── keylayout
│   │   ├── AVRCP.kl
│   │   ├── h2w_headset.kl
│   │   ├── m801_88-gpiokey.kl
│   │   ├── qwerty.kl
│   │   └── USB-compliant_keyboard.kl
│   ├── share
│   │   ├── alsa
│   │   │   ├── alsa.conf
│   │   │   ├── cards
│   │   │   │   └── aliases.conf
│   │   │   └── pcm
│   │   │       ├── center_lfe.conf
│   │   │       ├── default.conf
│   │   │       ├── dmix.conf
│   │   │       ├── dpl.conf
│   │   │       ├── dsnoop.conf
│   │   │       ├── front.conf
│   │   │       ├── iec958.conf
│   │   │       ├── modem.conf
│   │   │       ├── rear.conf
│   │   │       ├── side.conf
│   │   │       ├── surround40.conf
│   │   │       ├── surround41.conf
│   │   │       ├── surround50.conf
│   │   │       ├── surround51.conf
│   │   │       └── surround71.conf
│   │   ├── bmd
│   │   │   ├── RFFspeed_501.bmd
│   │   │   └── RFFstd_501.bmd
│   │   └── zoneinfo
│   │       ├── zoneinfo.dat
│   │       ├── zoneinfo.idx
│   │       └── zoneinfo.version
│   └── srec
│       └── config
│           └── en.us
│               ├── baseline11k.par
│               ├── baseline8k.par
│               ├── baseline.par
│               ├── dictionary
│               │   ├── basic.ok
│               │   ├── cmu6plus.ok.zip
│               │   └── enroll.ok
│               ├── g2p
│               │   └── en-US-ttp.data
│               ├── grammars
│               │   ├── boolean.g2g
│               │   ├── phone_type_choice.g2g
│               │   └── VoiceDialer.g2g
│               └── models
│                   ├── generic11_f.swimdl
│                   ├── generic11.lda
│                   ├── generic11_m.swimdl
│                   ├── generic8_f.swimdl
│                   ├── generic8.lda
│                   ├── generic8_m.swimdl
│                   └── generic.swiarb
├── wifi
│   ├── ar6000.ko
│   └── ath6k
│       └── AR6003
│           ├── hw2.0
│           │   ├── athtcmd_ram.bin
│           │   ├── athwlan.bin.z77
│           │   ├── bdata.SD31.bin
│           │   ├── data.patch.hw2_0.bin
│           │   ├── device.bin
│           │   └── otp.bin.z77
│           └── hw2.1.1
│               ├── athtcmd_ram.bin
│               ├── athwlan.bin
│               ├── athwlan_mobile.bin
│               ├── athwlan_router.bin
│               ├── athwlan_tablet.bin
│               ├── bdata.SD31.bin
│               ├── calData_AR6103_A05_golden.bin
│               ├── data.patch.hw3_0.bin
│               ├── device.bin
│               └── otp.bin
└── xbin
    ├── add-property-tag
    ├── agent
    ├── attest
    ├── avinfo
    ├── avtest
    ├── bdaddr
    ├── btool
    ├── bttest
    ├── check-lost+found
    ├── cpueater
    ├── crasher
    ├── daemonize
    ├── dbus-monitor
    ├── dbus-send
    ├── dexdump
    ├── directiotest
    ├── hciconfig
    ├── hcidump
    ├── hcitool
    ├── hstest
    ├── l2ping
    ├── l2test
    ├── latencytop
    ├── librank
    ├── lmptest
    ├── nc
    ├── netperf
    ├── netserver
    ├── opcontrol
    ├── oprofiled
    ├── procmem
    ├── procrank
    ├── rawbu
    ├── rctest
    ├── rfcomm
    ├── scotest
    ├── scp
    ├── sdptest
    ├── showmap
    ├── showslab
    ├── sqlite3
    ├── ssh
    ├── strace
    ├── su
    ├── tcpdump
    ├── timeinfo
    └── vfp-crasher

51 directories, 708 files
</pre>
<a href="OneKeyUpdate.html#DIR">top</a>

<p>有一个文件，META/filesystem_config.txt，里面记录了system下的各目录，文件的权限及owner</p>

<pre class="example">
system 0 0 755
system/wifi 0 0 755
system/wifi/ar6000.ko 0 0 644
system/wifi/ath6k 0 0 755
system/wifi/ath6k/AR6003 0 0 755
system/wifi/ath6k/AR6003/hw2.0 0 0 755
system/wifi/ath6k/AR6003/hw2.0/otp.bin.z77 0 0 644
system/wifi/ath6k/AR6003/hw2.0/device.bin 0 0 644
system/wifi/ath6k/AR6003/hw2.0/bdata.SD31.bin 0 0 644
system/wifi/ath6k/AR6003/hw2.0/athtcmd_ram.bin 0 0 644
</pre>

<p>这里面的权限的设定，是由fs_config设置的，这个程序的源码在build/tools/fs_config/下
fs_config.c中包含了一个头文件
<a name="include" id="include"></a>
&quot;private/android_filesystem_config.h&quot;
这个.h文件的路径在
system/core/include/private/android_filesystem_config.h</p>


<p>下面Makefile里还有一段代码</p>

<pre class="example">
# OTA update package

name := $(TARGET_PRODUCT)
ifeq ($(TARGET_BUILD_TYPE),debug)
  name := $(name)_debug
endif
name := $(name)-ota-$(FILE_NAME_TAG)

INTERNAL_OTA_PACKAGE_TARGET := $(PRODUCT_OUT)/$(name).zip

$(INTERNAL_OTA_PACKAGE_TARGET): KEY_CERT_PAIR := $(DEFAULT_KEY_CERT_PAIR)

$(INTERNAL_OTA_PACKAGE_TARGET): $(BUILT_TARGET_FILES_PACKAGE) $(OTATOOLS)
        @echo &quot;Package OTA: $@&quot;
        $(hide) ./build/tools/releasetools/ota_from_target_files -v \
           -p $(HOST_OUT) \
           -k $(KEY_CERT_PAIR) \
           $(BUILT_TARGET_FILES_PACKAGE) $@

.PHONY: otapackage
otapackage: $(INTERNAL_OTA_PACKAGE_TARGET)
</pre>

<p>关键的代码是</p>

<pre class="example">
        $(hide) ./build/tools/releasetools/ota_from_target_files -v \
           -p $(HOST_OUT) \
           -k $(KEY_CERT_PAIR) \
           $(BUILT_TARGET_FILES_PACKAGE) $@
</pre>

<p>这里面的脚本ota_from_target_file是一个python脚本，来制作OTA升级的zip包</p>

<p>这个文件存在于build/tools/releasetools/</p>

<p>可以先执行一下这个脚本，看看输出的帮助信息</p>

<pre class="example">
./ota_from_target_files

Given a target-files zipfile, produces an OTA package that installs
that build.  An incremental OTA is produced if -i is given, otherwise
a full OTA is produced.

Usage:  ota_from_target_files [flags] input_target_files output_ota_package

  -b  (--board_config)  &lt;file&gt;
      Deprecated.

  -k  (--package_key)  &lt;key&gt;
      Key to use to sign the package (default is
      &quot;build/target/product/security/testkey&quot;).

  -i  (--incremental_from)  &lt;file&gt;
      Generate an incremental OTA using the given target-files zip as
      the starting build.

  -w  (--wipe_user_data)
      Generate an OTA package that will wipe the user data partition
      when installed.

  -n  (--no_prereq)
      Omit the timestamp prereq check normally included at the top of
      the build scripts (used for developer OTA packages which
      legitimately need to go back and forth).

  -e  (--extra_script)  &lt;file&gt;
      Insert the contents of file at the end of the update script.

  -p  (--path)  &lt;dir&gt;
      Prepend &lt;dir&gt;/bin to the list of places to search for binaries
      run by this script, and expect to find jars in &lt;dir&gt;/framework.

  -s  (--device_specific) &lt;file&gt;
      Path to the python module containing device-specific
      releasetools code.

  -x  (--extra)  &lt;key=value&gt;
      Add a key/value pair to the 'extras' dict, which device-specific
      extension code may look at.

  -v  (--verbose)
      Show command lines being executed.

  -h  (--help)
      Display this usage message and exit.
</pre>

<p>这些参数当中，我们主要关注p,k以及w参数，-w表示要清除掉userdata分区的，这也是需要解决的问题，如何将data分区下的希望保留的数据，不在升级过程中被擦除掉。</p>

<p>下面就要分析一下文件内容了</p>

<p>首先从入口函数开始</p>

&lt;exmaple&gt;
if __name__ == '__main__':
<blockquote>
<p class="quoted">try:
common.CloseInheritedPipes()
main(sys.argv[1:])
except common.ExternalError, e:
print
print &quot;   ERROR: %s&quot; % (e,)
print
sys.exit(1)
&lt;/example&gt;</p>
</blockquote>

<p>调用了main函数</p>

<pre class="example">
def main(argv):

  def option_handler(o, a):
    if o in (&quot;-b&quot;, &quot;--board_config&quot;):
      pass   # deprecated
    elif o in (&quot;-k&quot;, &quot;--package_key&quot;):
      OPTIONS.package_key = a
    elif o in (&quot;-i&quot;, &quot;--incremental_from&quot;):
      OPTIONS.incremental_source = a
    elif o in (&quot;-w&quot;, &quot;--wipe_user_data&quot;):
      OPTIONS.wipe_user_data = True
    elif o in (&quot;-n&quot;, &quot;--no_prereq&quot;):
      OPTIONS.omit_prereq = True
    elif o in (&quot;-e&quot;, &quot;--extra_script&quot;):
      OPTIONS.extra_script = a
    elif o in (&quot;--worker_threads&quot;):
      OPTIONS.worker_threads = int(a)
    else:
      return False
    return True

  args = common.ParseOptions(argv, __doc__,
                             extra_opts=&quot;b:k:i:d:wne:&quot;,
                             extra_long_opts=[&quot;board_config=&quot;,
                                              &quot;package_key=&quot;,
                                              &quot;incremental_from=&quot;,
                                              &quot;wipe_user_data&quot;,
                                              &quot;no_prereq&quot;,
                                              &quot;extra_script=&quot;,
                                              &quot;worker_threads=&quot;],
                             extra_option_handler=option_handler)

  if len(args) != 2:
    common.Usage(__doc__)
    sys.exit(1)

解析各种参数

  if OPTIONS.extra_script is not None:
    OPTIONS.extra_script = open(OPTIONS.extra_script).read()

如果存在的话，读取额外的脚本

  print &quot;unzipping target target-files...&quot;
  OPTIONS.input_tmp = common.UnzipTemp(args[0])

将输入的压缩包解包

  OPTIONS.target_tmp = OPTIONS.input_tmp
  input_zip = zipfile.ZipFile(args[0], &quot;r&quot;)
  OPTIONS.info_dict = common.LoadInfoDict(input_zip)
  if OPTIONS.verbose:
    print &quot;--- target info ---&quot;
    common.DumpInfoDict(OPTIONS.info_dict)

  if OPTIONS.device_specific is None:
    OPTIONS.device_specific = OPTIONS.info_dict.get(&quot;tool_extensions&quot;, None)
  if OPTIONS.device_specific is not None:
    OPTIONS.device_specific = os.path.normpath(OPTIONS.device_specific)
    print &quot;using device-specific extensions in&quot;, OPTIONS.device_specific

  if OPTIONS.package_key:
    temp_zip_file = tempfile.NamedTemporaryFile()
    output_zip = zipfile.ZipFile(temp_zip_file, &quot;w&quot;,
                                 compression=zipfile.ZIP_DEFLATED)
  else:
    output_zip = zipfile.ZipFile(args[1], &quot;w&quot;,
                                 compression=zipfile.ZIP_DEFLATED)

设置输出文件，如果要签名，则还需要一个临时文件

  if OPTIONS.incremental_source is None:
    WriteFullOTAPackage(input_zip, output_zip)
  else:
    print &quot;unzipping source target-files...&quot;
    OPTIONS.source_tmp = common.UnzipTemp(OPTIONS.incremental_source)
    source_zip = zipfile.ZipFile(OPTIONS.incremental_source, &quot;r&quot;)
    OPTIONS.target_info_dict = OPTIONS.info_dict
    OPTIONS.source_info_dict = common.LoadInfoDict(source_zip)
    if OPTIONS.verbose:
      print &quot;--- source info ---&quot;
      common.DumpInfoDict(OPTIONS.source_info_dict)
    WriteIncrementalOTAPackage(input_zip, source_zip, output_zip)

根据参数，创建增量升级包还是完全升级包

  output_zip.close()
  if OPTIONS.package_key:
    SignOutput(temp_zip_file.name, args[1])
    temp_zip_file.close()

如果需要的话，签名

  common.Cleanup()

  print &quot;done.&quot;
</pre>

<p>主要功能还是函数WriteFullOTAPackage</p>

<pre class="example">
def WriteFullOTAPackage(input_zip, output_zip):
  # TODO: how to determine this?  We don't know what version it will
  # be installed on top of.  For now, we expect the API just won't
  # change very often.
  script = edify_generator.EdifyGenerator(3, OPTIONS.info_dict)

  metadata = {&quot;post-build&quot;: GetBuildProp(&quot;ro.build.fingerprint&quot;, input_zip),
              &quot;pre-device&quot;: GetBuildProp(&quot;ro.product.device&quot;, input_zip),
              &quot;post-timestamp&quot;: GetBuildProp(&quot;ro.build.date.utc&quot;, input_zip),
              }

获取一些环境变量

  device_specific = common.DeviceSpecificParams(
      input_zip=input_zip,
      input_version=OPTIONS.info_dict[&quot;recovery_api_version&quot;],
      output_zip=output_zip,
      script=script,
      input_tmp=OPTIONS.input_tmp,
      metadata=metadata,
      info_dict=OPTIONS.info_dict)

设备相关参数

  if not OPTIONS.omit_prereq:
    ts = GetBuildProp(&quot;ro.build.date.utc&quot;, input_zip)
    script.AssertOlderBuild(ts)

如果需要，在脚本中增加一个Assert语句，要求update.zip包只能用于升级老的系统

  AppendAssertions(script, input_zip)

如果需要，在脚本中增加一个Assert语句，要求update.zip包只能用于同一设备，即目标设备的ro.product.device必须跟update.zip中的相同

  device_specific.FullOTA_Assertions()

callback，用于调用设备相关代码。

  script.ShowProgress(0.5, 0)

在升级脚本中加入显示进度的语句。第一个参数表示，下面的操作到下一条同类语句或者到末尾，所用的时间在总体时间中的比例。第二个参数用于控制显示的速度，比如50则表示下面的操作估计50秒完成，要求进度条显示线程用50秒显示这一部分的进度，0表示不自动更新，用SetProgress手动控制

  if OPTIONS.wipe_user_data:
    script.FormatPartition(&quot;/data&quot;)

如果需要，在脚本中增加语句，擦除userdata分区

  script.FormatPartition(&quot;/system&quot;)
在脚本中增加语句，擦除system分区
  script.Mount(&quot;/system&quot;)
在脚本中增加语句，挂载system分区
  script.UnpackPackageDir(&quot;recovery&quot;, &quot;/system&quot;)
  script.UnpackPackageDir(&quot;system&quot;, &quot;/system&quot;)
在脚本中增加语句，将recovery以及system中的内容拷贝到/system目录。
其中，recovery目录包含一个patch，以及使用该patch的脚本

  symlinks = CopySystemFiles(input_zip, output_zip)
  script.MakeSymlinks(symlinks)
从输入zip包的/system拷贝文件到输出zip包/system。
由于这个过程不支持链接文件，所以它将这些文件返回。
用MakeSymlinks建立这些链接文件。
所有的链接文件都指向toolbox。

  boot_img = common.File(&quot;boot.img&quot;, common.BuildBootableImage(
      os.path.join(OPTIONS.input_tmp, &quot;BOOT&quot;)))
  recovery_img = common.File(&quot;recovery.img&quot;, common.BuildBootableImage(
      os.path.join(OPTIONS.input_tmp, &quot;RECOVERY&quot;)))
  MakeRecoveryPatch(output_zip, recovery_img, boot_img)
MakeRecoveryPath做了两件事
1.在输出的zip包中生成了一个patch:recovery/recovery-from-boot.p(boot.img和recovery.img的patch)，它最后会位于system/recovery-from-boot.p
2.在输出的zip包中生成了一个脚本：recovery/etc/install-recovery.sh，它最后会位于system/etc/install-recovery.sh

  Item.GetMetadata(input_zip)
从META/filesystem_config.txt中获得system目录下的各文件权限信息
  Item.Get(&quot;system&quot;).SetPermissions(script)
在脚本中增加语句，设置system目录下文件的权限及owner等

  common.CheckSize(boot_img.data, &quot;boot.img&quot;, OPTIONS.info_dict) 检查boot.img文件大小是否超标
  common.ZipWriteStr(output_zip, &quot;boot.img&quot;, boot_img.data) 将boot.img放到输出的zip包中
  script.ShowProgress(0.2, 0)
更新进度条

  script.ShowProgress(0.2, 10)
  script.WriteRawImage(&quot;/boot&quot;, &quot;boot.img&quot;)
在脚本中增加语句，将boot.img写到boot分区

  script.ShowProgress(0.1, 0)
  device_specific.FullOTA_InstallEnd()
callback函数

  if OPTIONS.extra_script is not None:
    script.AppendExtra(OPTIONS.extra_script)
如果有额外的脚本，加入进来

  script.UnmountAll()
在脚本中增加语句，umount所有分区
  script.AddToZip(input_zip, output_zip)
1.将前面生成的脚本输出到：META-INF/com/google/android/updater-script中
这个路径就在update.zip包中，也就是前面提到的full-***.zip包中
2.将升级程序 OTA/bin/updater从输入的zip包中拷贝到输出的zip包中
META-INF/com/google/android/update-binary
  WriteMetadata(metadata, output_zip)
将前面获取的metadata写入输出包的文件中:META-INF/com/android/metadata
</pre>
至此，我们就得到了一个update.zip包，可以开始升级了

<p>下面看一下updater-script文件中的内容</p>

<pre class="example">
assert(!less_than_int(1334293359, getprop(&quot;ro.build.date.utc&quot;)));
assert(getprop(&quot;ro.product.device&quot;) == &quot;m801&quot; ||
       getprop(&quot;ro.build.product&quot;) == &quot;m801&quot;);
show_progress(0.500000, 0);
format(&quot;yaffs2&quot;, &quot;MTD&quot;, &quot;system&quot;);
mount(&quot;yaffs2&quot;, &quot;MTD&quot;, &quot;system&quot;, &quot;/system&quot;);
package_extract_dir(&quot;recovery&quot;, &quot;/system&quot;);
package_extract_dir(&quot;system&quot;, &quot;/system&quot;);
symlink(&quot;busybox&quot;, &quot;/system/bin/cp&quot;, &quot;/system/bin/grep&quot;,
        &quot;/system/bin/tar&quot;, &quot;/system/bin/unzip&quot;,
        &quot;/system/bin/vi&quot;);
symlink(&quot;toolbox&quot;, &quot;/system/bin/cat&quot;, &quot;/system/bin/chmod&quot;,
        &quot;/system/bin/chown&quot;, &quot;/system/bin/cmp&quot;, &quot;/system/bin/date&quot;,
        &quot;/system/bin/dd&quot;, &quot;/system/bin/df&quot;, &quot;/system/bin/dmesg&quot;,
        &quot;/system/bin/getevent&quot;, &quot;/system/bin/getprop&quot;, &quot;/system/bin/hd&quot;,
        &quot;/system/bin/id&quot;, &quot;/system/bin/ifconfig&quot;, &quot;/system/bin/iftop&quot;,
        &quot;/system/bin/insmod&quot;, &quot;/system/bin/ioctl&quot;, &quot;/system/bin/ionice&quot;,
        &quot;/system/bin/kill&quot;, &quot;/system/bin/ln&quot;, &quot;/system/bin/log&quot;,
        &quot;/system/bin/ls&quot;, &quot;/system/bin/lsmod&quot;, &quot;/system/bin/lsof&quot;,
        &quot;/system/bin/mkdir&quot;, &quot;/system/bin/mount&quot;, &quot;/system/bin/mv&quot;,
        &quot;/system/bin/nandread&quot;, &quot;/system/bin/netstat&quot;,
        &quot;/system/bin/newfs_msdos&quot;, &quot;/system/bin/notify&quot;, &quot;/system/bin/printenv&quot;,
        &quot;/system/bin/ps&quot;, &quot;/system/bin/reboot&quot;, &quot;/system/bin/renice&quot;,
        &quot;/system/bin/rm&quot;, &quot;/system/bin/rmdir&quot;, &quot;/system/bin/rmmod&quot;,
        &quot;/system/bin/route&quot;, &quot;/system/bin/schedtop&quot;, &quot;/system/bin/sendevent&quot;,
        &quot;/system/bin/setconsole&quot;, &quot;/system/bin/setprop&quot;, &quot;/system/bin/sleep&quot;,
        &quot;/system/bin/smd&quot;, &quot;/system/bin/start&quot;, &quot;/system/bin/stop&quot;,
        &quot;/system/bin/sync&quot;, &quot;/system/bin/top&quot;, &quot;/system/bin/umount&quot;,
        &quot;/system/bin/uptime&quot;, &quot;/system/bin/vmstat&quot;, &quot;/system/bin/watchprops&quot;,
        &quot;/system/bin/wipe&quot;);
set_perm_recursive(0, 0, 0755, 0644, &quot;/system&quot;);
set_perm_recursive(0, 2000, 0755, 0755, &quot;/system/bin&quot;);
set_perm(0, 3003, 02750, &quot;/system/bin/netcfg&quot;);
set_perm(0, 3004, 02755, &quot;/system/bin/ping&quot;);
set_perm(0, 2000, 06750, &quot;/system/bin/run-as&quot;);
set_perm_recursive(1002, 1002, 0755, 0440, &quot;/system/etc/bluetooth&quot;);
set_perm(0, 0, 0755, &quot;/system/etc/bluetooth&quot;);
set_perm(1000, 1000, 0640, &quot;/system/etc/bluetooth/auto_pairing.conf&quot;);
set_perm(3002, 3002, 0444, &quot;/system/etc/bluetooth/blacklist.conf&quot;);
set_perm(1002, 1002, 0440, &quot;/system/etc/dbus.conf&quot;);
set_perm(1014, 2000, 0550, &quot;/system/etc/dhcpcd/dhcpcd-run-hooks&quot;);
set_perm(0, 2000, 0550, &quot;/system/etc/init.goldfish.sh&quot;);
set_perm(0, 0, 0544, &quot;/system/etc/install-recovery.sh&quot;);
set_perm_recursive(0, 0, 0755, 0555, &quot;/system/etc/ppp&quot;);
set_perm_recursive(0, 2000, 0755, 0755, &quot;/system/xbin&quot;);
set_perm(0, 0, 06755, &quot;/system/xbin/librank&quot;);
set_perm(0, 0, 06755, &quot;/system/xbin/procmem&quot;);
set_perm(0, 0, 06755, &quot;/system/xbin/procrank&quot;);
set_perm(0, 0, 06755, &quot;/system/xbin/su&quot;);
set_perm(0, 0, 06755, &quot;/system/xbin/tcpdump&quot;);
show_progress(0.200000, 0);
show_progress(0.200000, 10);
assert(package_extract_file(&quot;boot.img&quot;, &quot;/tmp/boot.img&quot;),
       write_raw_image(&quot;/tmp/boot.img&quot;, &quot;boot&quot;),
       delete(&quot;/tmp/boot.img&quot;));
show_progress(0.100000, 0);
unmount(&quot;/system&quot;);
</pre>

<p>系统上电以后，先运行bootloader，在bootloader中，根据按键的判定条件，选择进入recovery模式。</p>

<p>recovery模式会装载recovery分区，该分区包含了recover.img。</p>

<p>recovery.img包含了与boot.img中相同的标准内核，以及recovery根文件系统</p>

<p>下面学习一下recovery.img的生成过程</p>

<p>参考build/core/Makefile</p>

<pre class="example">
$(INSTALLED_RECOVERYIMAGE_TARGET): $(MKBOOTFS) $(MKBOOTIMG) $(MINIGZIP) \
		$(INSTALLED_RAMDISK_TARGET) \
		$(INSTALLED_BOOTIMAGE_TARGET) \
		$(recovery_binary) \
		$(recovery_initrc) $(recovery_kernel) \
		$(TARGET_RECOVERY_INIT_RC) \
		$(INSTALLED_2NDBOOTLOADER_TARGET) \
		$(recovery_build_prop) $(recovery_resource_deps) \
		$(recovery_fstab) \
		$(RECOVERY_INSTALL_OTA_KEYS)
</pre>

<p>上面是依赖关系</p>

<p>下面是定义</p>

<pre class="example">
INSTALLED_RECOVERYIMAGE_TARGET := $(PRODUCT_OUT)/recovery.img
</pre>

<p>它依赖很多其他目标：</p>

<p>1. 上面的几个宏定义在 build/core/config.mk中</p>

<pre class="example">
MKBOOTFS := $(HOST_OUT_EXECUTABLES)/mkbootfs$(HOST_EXECUTABLE_SUFFIX)
MINIGZIP := $(HOST_OUT_EXECUTABLES)/minigzip$(HOST_EXECUTABLE_SUFFIX)
MKBOOTIMG := $(HOST_OUT_EXECUTABLES)/mkbootimg$(HOST_EXECUTABLE_SUFFIX)
</pre>

<p>2. INSTALLED_RAMDISK_TARGET 标准根文件系统ramdisk.img
在 build/core/Makefile中</p>

<pre class="example">
BUILT_RAMDISK_TARGET := $(PRODUCT_OUT)/ramdisk.img

# We just build this directly to the install location.
INSTALLED_RAMDISK_TARGET := $(BUILT_RAMDISK_TARGET)
</pre>

<p>3. INSTALLED_BOOTIMAGE_TARGET boot.img，标准内核以及标准根文件系统
在 build/core/Makefile中</p>

<pre class="example">
INSTALLED_BOOTIMAGE_TARGET := $(PRODUCT_OUT)/boot.img
</pre>

<p>4. recovery_binary recovery可执行程序，源码位于bootable/recovery/下</p>

<pre class="example">
recovery_binary := $(call intermediates-dir-for,EXECUTABLES,recovery)/recovery
</pre>

<p>5. recovery_initrc recovery模式的init.rc 位于bootable/recovery/etc/init.rc</p>

<pre class="example">
recovery_initrc := $(call include-path-for, recovery)/etc/init.rc
</pre>

<p>6. recovery_kernel recovery模式的kernel，和标准内核一样</p>

<pre class="example">
recovery_kernel := $(INSTALLED_KERNEL_TARGET) # same as a non-recovery system
</pre>

<p>7. TARGET_RECOVERY_INIT_RC没有找到</p>

<p>8. INSTALLED_2NDBOOTLOADER_TARGET貌似没有用到</p>

<p>9. recovery_build_prop recovery模式的build.prop 与标准模式相同</p>

<pre class="example">
recovery_build_prop := $(INSTALLED_BUILD_PROP_TARGET)
</pre>

<p>10. recovery_resource_deps recovery模式使用的res，位于recovery/custom/{product_name}/res,以及设备自定义部分</p>

<pre class="example">
recovery_resources_common := $(call include-path-for, recovery)/res
recovery_resources_private := $(strip $(wildcard $(TARGET_DEVICE_DIR)/recovery/res))
recovery_resource_deps := $(shell find $(recovery_resources_common) \
  $(recovery_resources_private) -type f)
</pre>

<p>11. RECOVERY_INSTALL_OTA_KEYS ota密钥</p>

<pre class="example">
# Generate a file containing the keys that will be read by the
# recovery binary.
RECOVERY_INSTALL_OTA_KEYS := \
        $(call intermediates-dir-for,PACKAGING,ota_keys)/keys
</pre>

<p>接下来，为准备生成img准备内容, out/target/product/{product_name}/recovery及其子目录</p>

<pre class="example">
        @echo ----- Making recovery image ------
        rm -rf $(TARGET_RECOVERY_OUT)
        mkdir -p $(TARGET_RECOVERY_OUT)
        mkdir -p $(TARGET_RECOVERY_ROOT_OUT)
        mkdir -p $(TARGET_RECOVERY_ROOT_OUT)/etc
        mkdir -p $(TARGET_RECOVERY_ROOT_OUT)/tmp
</pre>

<pre class="example">
        echo Copying baseline ramdisk...
        cp -R $(TARGET_ROOT_OUT) $(TARGET_RECOVERY_OUT)
从标准根文件系统拷贝所有文件
        rm $(TARGET_RECOVERY_ROOT_OUT)/init*.rc
删除文件
        echo Modifying ramdisk contents...
</pre>

<pre class="example">
        cp -f $(recovery_initrc) $(TARGET_RECOVERY_ROOT_OUT)/
        $(if $(TARGET_RECOVERY_INIT_RC), \
          cp -f $(TARGET_RECOVERY_INIT_RC) $(TARGET_RECOVERY_ROOT_OUT)/)
拷贝recovery模式的核心文件init.rc
        cp -f $(recovery_binary) $(TARGET_RECOVERY_ROOT_OUT)/sbin/
拷贝recovery模式的核心文件recovery
        cp -rf $(recovery_resources_common) $(TARGET_RECOVERY_ROOT_OUT)/
        $(foreach item,$(recovery_resources_private), \
          cp -rf $(item) $(TARGET_RECOVERY_ROOT_OUT)/)
        $(foreach item,$(recovery_fstab), \
          cp -f $(item) $(TARGET_RECOVERY_ROOT_OUT)/etc/recovery.fstab)
        cp $(RECOVERY_INSTALL_OTA_KEYS) $(TARGET_RECOVERY_ROOT_OUT)/res/keys
拷贝资源文件及密钥文件
        cat $(INSTALLED_DEFAULT_PROP_TARGET) $(recovery_build_prop) \
                &gt; $(TARGET_RECOVERY_ROOT_OUT)/default.prop
生成属性文件default.prop,它包含了标准根文件系统的default.prop
        $(MKBOOTFS) $(TARGET_RECOVERY_ROOT_OUT) | $(MINIGZIP) &gt; $(recovery_ramdisk)
压缩recovery根文件系统
        $(MKBOOTIMG) $(INTERNAL_RECOVERYIMAGE_ARGS) --output $@
        @echo ----- Made recovery image -------- $@
        $(hide) $(call assert-max-image-size,$@,$(BOARD_RECOVERYIMAGE_PARTITION_SIZE),raw)
和内核一起生成recovery.img
</pre>


<p>recovery根文件系统目录结构</p>

<pre class="example">
.
└── root
    ├── data
    ├── default.prop
    ├── dev
    ├── etc
    │   └── recovery.fstab
    ├── init
    ├── initlogo.rle
    ├── init.m801_88.rc
    ├── init.rc
    ├── lib
    │   └── modules
    │       ├── ehci-hcd.ko
    │       ├── ohci-hcd.ko
    │       ├── tcc_init_nand.ko
    │       ├── tcc_mtd.ko
    │       ├── tcc_nand.ko
    │       ├── tcc_ndd.ko
    │       └── ufsd.ko
    ├── proc
    ├── res
    │   ├── images
    │   │   ├── icon_error.png
    │   │   ├── icon_installing.png
    │   │   ├── indeterminate1.png
    │   │   ├── indeterminate2.png
    │   │   ├── indeterminate3.png
    │   │   ├── indeterminate4.png
    │   │   ├── indeterminate5.png
    │   │   ├── indeterminate6.png
    │   │   ├── progress_empty.png
    │   │   └── progress_fill.png
    │   └── keys
    ├── sbin
    │   ├── adbd
    │   ├── recovery
    │   └── ueventd -&gt; ../init
    ├── sys
    ├── system
    ├── tmp
    ├── ueventd.goldfish.rc
    ├── ueventd.m801_88.rc
    └── ueventd.rc

13 directories, 30 files
</pre>

<p>系统进入recovery模式之后，还是要关心init.rc文件的 这个文件来自bootable/recovery/etc/init.rc</p>

<pre class="example">
on early-init
    insmod /lib/modules/tcc_nand.ko
    insmod /lib/modules/tcc_mtd.ko
    insmod /lib/modules/tcc_ndd.ko
    start ueventd
装载模块

on init
    export PATH /sbin
    export ANDROID_ROOT /system
    export ANDROID_DATA /data
    export EXTERNAL_STORAGE /sdcard
设置环境变量

    symlink /system/etc /etc
建立符号链接

    mkdir /sdcard
    mkdir /system
    mkdir /data
    mkdir /cache
建立几个目录
    mount /tmp /tmp tmpfs
挂载tmp目录为内存文件系统

on boot

    ifup lo
    hostname localhost
    domainname localdomain
lo网络部分的设置

    class_start default

service ueventd /sbin/ueventd
    critical

service recovery /sbin/recovery
启动recovery主程序

service adbd /sbin/adbd recovery
    disabled

on property:persist.service.adb.enable=1
    start adbd

on property:persist.service.adb.enable=0
    stop adbd
判断要不要启动adb
</pre>

<p>init主程序还会装载属性配置文件/default.prop</p>

<p>这里最终要的就是recovery主程序</p>

<p>这个文件是/bootable/recovery/recovery.c， 有不到1k行</p>

<p>首先，关注一下文件中的一段注释</p>

<pre class="example">
/*
 * The recovery tool communicates with the main system through /cache files.
 *   /cache/recovery/command - INPUT - command line for tool, one arg per line
 *   /cache/recovery/log - OUTPUT - combined log file from recovery run(s)
 *   /cache/recovery/intent - OUTPUT - intent that was passed in
 *
 * The arguments which may be supplied in the recovery.command file:
 *   --send_intent=anystring - write the text out to recovery.intent
 *   --update_package=path - verify install an OTA package file
 *   --wipe_data - erase user data (and cache), then reboot
 *   --wipe_cache - wipe cache (but not user data), then reboot
 *   --set_encrypted_filesystem=on|off - enables / diasables encrypted fs
 *
 * After completing, we remove /cache/recovery/command and reboot.
 * Arguments may also be supplied in the bootloader control block (BCB).
 * These important scenarios must be safely restartable at any point:
 *
 * FACTORY RESET
 * 1. user selects &quot;factory reset&quot;
 * 2. main system writes &quot;--wipe_data&quot; to /cache/recovery/command
 * 3. main system reboots into recovery
 * 4. get_args() writes BCB with &quot;boot-recovery&quot; and &quot;--wipe_data&quot;
 *    -- after this, rebooting will restart the erase --
 * 5. erase_volume() reformats /data
 * 6. erase_volume() reformats /cache
 * 7. finish_recovery() erases BCB
 *    -- after this, rebooting will restart the main system --
 * 8. main() calls reboot() to boot main system
 *
 * OTA INSTALL
 * 1. main system downloads OTA package to /cache/some-filename.zip
 * 2. main system writes &quot;--update_package=/cache/some-filename.zip&quot;
 * 3. main system reboots into recovery
 * 4. get_args() writes BCB with &quot;boot-recovery&quot; and &quot;--update_package=...&quot;
 *    -- after this, rebooting will attempt to reinstall the update --
 * 5. install_package() attempts to install the update
 *    NOTE: the package install must itself be restartable from any point
 * 6. finish_recovery() erases BCB
 *    -- after this, rebooting will (try to) restart the main system --
 * 7. ** if install failed **
 *    7a. prompt_and_wait() shows an error icon and waits for the user
 *    7b; the user reboots (pulling the battery, etc) into the main system
 * 8. main() calls maybe_install_firmware_update()
 *    ** if the update contained radio/hboot firmware **:
 *    8a. m_i_f_u() writes BCB with &quot;boot-recovery&quot; and &quot;--wipe_cache&quot;
 *        -- after this, rebooting will reformat cache &amp; restart main system --
 *    8b. m_i_f_u() writes firmware image into raw cache partition
 *    8c. m_i_f_u() writes BCB with &quot;update-radio/hboot&quot; and &quot;--wipe_cache&quot;
 *        -- after this, rebooting will attempt to reinstall firmware --
 *    8d. bootloader tries to flash firmware
 *    8e. bootloader writes BCB with &quot;boot-recovery&quot; (keeping &quot;--wipe_cache&quot;)
 *        -- after this, rebooting will reformat cache &amp; restart main system --
 *    8f. erase_volume() reformats /cache
 *    8g. finish_recovery() erases BCB
 *        -- after this, rebooting will (try to) restart the main system --
 * 9. main() calls reboot() to boot main system
 *
 * SECURE FILE SYSTEMS ENABLE/DISABLE
 * 1. user selects &quot;enable encrypted file systems&quot;
 * 2. main system writes &quot;--set_encrypted_filesystems=on|off&quot; to
 *    /cache/recovery/command
 * 3. main system reboots into recovery
 * 4. get_args() writes BCB with &quot;boot-recovery&quot; and
 *    &quot;--set_encrypted_filesystems=on|off&quot;
 *    -- after this, rebooting will restart the transition --
 * 5. read_encrypted_fs_info() retrieves encrypted file systems settings from /data
 *    Settings include: property to specify the Encrypted FS istatus and
 *    FS encryption key if enabled (not yet implemented)
 * 6. erase_volume() reformats /data
 * 7. erase_volume() reformats /cache
 * 8. restore_encrypted_fs_info() writes required encrypted file systems settings to /data
 *    Settings include: property to specify the Encrypted FS status and
 *    FS encryption key if enabled (not yet implemented)
 * 9. finish_recovery() erases BCB
 *    -- after this, rebooting will restart the main system --
 * 10. main() calls reboot() to boot main system
 */
</pre>

<p>然后，学习一下主程序</p>

<pre class="example">
int
main(int argc, char **argv) {
    time_t start = time(NULL);

    // If these fail, there's not really anywhere to complain...
    freopen(TEMPORARY_LOG_FILE, &quot;a&quot;, stdout); setbuf(stdout, NULL);
    freopen(TEMPORARY_LOG_FILE, &quot;a&quot;, stderr); setbuf(stderr, NULL);
    printf(&quot;Starting recovery on %s&quot;, ctime(&amp;start));
重定位标准输出和标准出错

    ui_init();
一个简单的ui系统，启动了一个event线程用于相应用户按键
    ui_set_background(BACKGROUND_ICON_INSTALLING);
    load_volume_table();
    get_args(&amp;argc, &amp;argv);
从misc分区以及cache:recovery/command文件中读入参数，写入到argc,argv中，如果有必要，写回misc分区。这里还不知道为什么说是misc分区

    int previous_runs = 0;
    const char *send_intent = NULL;
    const char *update_package = NULL;
    const char *encrypted_fs_mode = NULL;
    int wipe_data = 0, wipe_cache = 0;
    int toggle_secure_fs = 0;
    encrypted_fs_info encrypted_fs_data;

    int arg;
    while ((arg = getopt_long(argc, argv, &quot;&quot;, OPTIONS, NULL)) != -1) {
        switch (arg) {
        case 'p': previous_runs = atoi(optarg); break;
        case 's': send_intent = optarg; break;
        case 'u': update_package = optarg; break;
        case 'w': wipe_data = wipe_cache = 1; break;
        case 'c': wipe_cache = 1; break;
        case 'e': encrypted_fs_mode = optarg; toggle_secure_fs = 1; break;
        case 't': ui_show_text(1); break;
        case '?':
            LOGE(&quot;Invalid command argument\n&quot;);
            continue;
        }
    }
解析参数

    device_recovery_start();

    printf(&quot;Command:&quot;);
    for (arg = 0; arg &lt; argc; arg++) {
        printf(&quot; \&quot;%s\&quot;&quot;, argv[arg]);
    }
    printf(&quot;\n&quot;);
打印参数

    if (update_package) {
        // For backwards compatibility on the cache partition only, if
        // we're given an old 'root' path &quot;CACHE:foo&quot;, change it to
        // &quot;/cache/foo&quot;.
        if (strncmp(update_package, &quot;CACHE:&quot;, 6) == 0) {
            int len = strlen(update_package) + 10;
            char* modified_path = malloc(len);
            strlcpy(modified_path, &quot;/cache/&quot;, len);
            strlcat(modified_path, update_package+6, len);
            printf(&quot;(replacing path \&quot;%s\&quot; with \&quot;%s\&quot;)\n&quot;,
                   update_package, modified_path);
            update_package = modified_path;
        }
    }
    printf(&quot;\n&quot;);

    property_list(print_property, NULL);
    printf(&quot;\n&quot;);
打印系统属性到log文件

    int status = INSTALL_SUCCESS;

    if (toggle_secure_fs) {
        if (strcmp(encrypted_fs_mode,&quot;on&quot;) == 0) {
            encrypted_fs_data.mode = MODE_ENCRYPTED_FS_ENABLED;
            ui_print(&quot;Enabling Encrypted FS.\n&quot;);
        } else if (strcmp(encrypted_fs_mode,&quot;off&quot;) == 0) {
            encrypted_fs_data.mode = MODE_ENCRYPTED_FS_DISABLED;
            ui_print(&quot;Disabling Encrypted FS.\n&quot;);
        } else {
            ui_print(&quot;Error: invalid Encrypted FS setting.\n&quot;);
            status = INSTALL_ERROR;
        }

        // Recovery strategy: if the data partition is damaged, disable encrypted file systems.
        // This preventsthe device recycling endlessly in recovery mode.
        if ((encrypted_fs_data.mode == MODE_ENCRYPTED_FS_ENABLED) &amp;&amp;
                (read_encrypted_fs_info(&amp;encrypted_fs_data))) {
            ui_print(&quot;Encrypted FS change aborted, resetting to disabled state.\n&quot;);
            encrypted_fs_data.mode = MODE_ENCRYPTED_FS_DISABLED;
        }

        if (status != INSTALL_ERROR) {
            if (erase_volume(&quot;/data&quot;)) {
                ui_print(&quot;Data wipe failed.\n&quot;);
                status = INSTALL_ERROR;
            } else if (erase_volume(&quot;/cache&quot;)) {
                ui_print(&quot;Cache wipe failed.\n&quot;);
                status = INSTALL_ERROR;
            } else if ((encrypted_fs_data.mode == MODE_ENCRYPTED_FS_ENABLED) &amp;&amp;
                      (restore_encrypted_fs_info(&amp;encrypted_fs_data))) {
                ui_print(&quot;Encrypted FS change aborted.\n&quot;);
                status = INSTALL_ERROR;
            } else {
                ui_print(&quot;Successfully updated Encrypted FS.\n&quot;);
                status = INSTALL_SUCCESS;
            }
        }
    } else if (update_package != NULL) {
        status = install_package(update_package);
        if (status != INSTALL_SUCCESS) ui_print(&quot;Installation aborted.\n&quot;);
        ui_show_text(1);
    } else if (wipe_data) {
        if (device_wipe_data()) status = INSTALL_ERROR;
        if (erase_volume(&quot;/data&quot;)) status = INSTALL_ERROR;
        if (wipe_cache &amp;&amp; erase_volume(&quot;/cache&quot;)) status = INSTALL_ERROR;
        if (status != INSTALL_SUCCESS) ui_print(&quot;Data wipe failed.\n&quot;);
    } else if (wipe_cache) {
        if (wipe_cache &amp;&amp; erase_volume(&quot;/cache&quot;)) status = INSTALL_ERROR;
        if (status != INSTALL_SUCCESS) ui_print(&quot;Cache wipe failed.\n&quot;);
    } else {
        status = INSTALL_ERROR;  // No command specified
    }
根据不同的参数，执行不同的命令

    if (status != INSTALL_SUCCESS) ui_set_background(BACKGROUND_ICON_ERROR);
    if (status != INSTALL_SUCCESS || ui_text_visible()) {
        prompt_and_wait();
    }
前面的操作成功了，则重启，否则，等待用户选择具体操作

    // Otherwise, get ready to boot the main system...
    finish_recovery(send_intent);
1. 将前面定义的intent字符串写入CACHE:recovery/command 如果有的话
2. 将/tmp/recovery.log复制到CACHE:recovery/log
3. 清空misc分区，这样重启就不会进入recovery模式
4. 删除command文件 CACHE:recovery/command
    ui_print(&quot;Rebooting...\n&quot;);
    sync();
    reboot(RB_AUTOBOOT);
    return EXIT_SUCCESS;
}
</pre>

<p>我们要关注升级么，所以关注下面这个代码</p>

<pre class="example">
    } else if (update_package != NULL) {
        status = install_package(update_package);
        if (status != INSTALL_SUCCESS) ui_print(&quot;Installation aborted.\n&quot;);
        ui_show_text(1);
</pre>

<p>所以，重要的是</p>


<h4>install_package(update_package)</h4>

<p class="first">这个函数</p>

<p>在文件install.c中，和recovery.c一个目录下</p>

<pre class="example">
int
install_package(const char *path)
{
    ui_set_background(BACKGROUND_ICON_INSTALLING);
    ui_print(&quot;Finding update package...\n&quot;);
    ui_show_indeterminate_progress();
    LOGI(&quot;Update location: %s\n&quot;, path);
更新UI显示

    if (ensure_path_mounted(path) != 0) {
        LOGE(&quot;Can't mount %s\n&quot;, path);
        return INSTALL_CORRUPT;
    }
确保升级包所在的分区已经mount，通常为cache或者SD分区

    ui_print(&quot;Opening update package...\n&quot;);

    int numKeys;
    RSAPublicKey* loadedKeys = load_keys(PUBLIC_KEYS_FILE, &amp;numKeys);
    if (loadedKeys == NULL) {
        LOGE(&quot;Failed to load keys\n&quot;);
        return INSTALL_CORRUPT;
    }
    LOGI(&quot;%d key(s) loaded from %s\n&quot;, numKeys, PUBLIC_KEYS_FILE);
从/res/keys中装载公钥

    // Give verification half the progress bar...
    ui_print(&quot;Verifying update package...\n&quot;);
    ui_show_progress(
            VERIFICATION_PROGRESS_FRACTION,
            VERIFICATION_PROGRESS_TIME);

    int err;
    err = verify_file(path, loadedKeys, numKeys);
    free(loadedKeys);
    LOGI(&quot;verify_file returned %d\n&quot;, err);
    if (err != VERIFY_SUCCESS) {
        LOGE(&quot;signature verification failed\n&quot;);
        return INSTALL_CORRUPT;
    }

    /* Try to open the package.
     */
    ZipArchive zip;
    err = mzOpenZipArchive(path, &amp;zip);
    if (err != 0) {
        LOGE(&quot;Can't open %s\n(%s)\n&quot;, path, err != -1 ? strerror(err) : &quot;bad&quot;);
        return INSTALL_CORRUPT;
    }
打开升级包，将相关信息存到ZipArchive数据结构中

    /* Verify and install the contents of the package.
     */
    ui_print(&quot;Installing update...\n&quot;);
    return try_update_binary(path, &amp;zip);
调用try_update_binary()函数
}
</pre>

<p>下面关注try_update_binary()函数 在install.c中</p>

<pre class="example">
// If the package contains an update binary, extract it and run it.
static int
try_update_binary(const char *path, ZipArchive *zip) {
    const ZipEntry* binary_entry =
            mzFindZipEntry(zip, ASSUMED_UPDATE_BINARY_NAME);
找到压缩包的入口
    if (binary_entry == NULL) {
        mzCloseZipArchive(zip);
        return INSTALL_CORRUPT;
    }

    char* binary = &quot;/tmp/update_binary&quot;;
    unlink(binary);
    int fd = creat(binary, 0755);
    if (fd &lt; 0) {
        mzCloseZipArchive(zip);
        LOGE(&quot;Can't make %s\n&quot;, binary);
        return 1;
    }
    bool ok = mzExtractZipEntryToFile(zip, binary_entry, fd);
    close(fd);
    mzCloseZipArchive(zip);

    if (!ok) {
        LOGE(&quot;Can't copy %s\n&quot;, ASSUMED_UPDATE_BINARY_NAME);
        return 1;
    }
将压缩包中META-INF/com/google/android/update-binary解压到/tmp/update_binary

    int pipefd[2];
    pipe(pipefd);

    // When executing the update binary contained in the package, the
    // arguments passed are:
    //
    //   - the version number for this interface
    //
    //   - an fd to which the program can write in order to update the
    //     progress bar.  The program can write single-line commands:
    //
    //        progress &lt;frac&gt; &lt;secs&gt;
    //            fill up the next &lt;frac&gt; part of of the progress bar
    //            over &lt;secs&gt; seconds.  If &lt;secs&gt; is zero, use
    //            set_progress commands to manually control the
    //            progress of this segment of the bar
    //
    //        set_progress &lt;frac&gt;
    //            &lt;frac&gt; should be between 0.0 and 1.0; sets the
    //            progress bar within the segment defined by the most
    //            recent progress command.
    //
    //        firmware &lt;&quot;hboot&quot;|&quot;radio&quot;&gt; &lt;filename&gt;
    //            arrange to install the contents of &lt;filename&gt; in the
    //            given partition on reboot.
    //
    //            (API v2: &lt;filename&gt; may start with &quot;PACKAGE:&quot; to
    //            indicate taking a file from the OTA package.)
    //
    //            (API v3: this command no longer exists.)
    //
    //        ui_print &lt;string&gt;
    //            display &lt;string&gt; on the screen.
    //
    //   - the name of the package zip file.
    //
将会创建新的进程，执行/tmp/update_binary
同时会传给该进程一些参数，最终哦功能要的是一个管道fd，提供IPC
新进程产生后，父进程变成了一个服务进程，提供UI更新服务
    - progress
    - set_progress
    - ui_print

    char** args = malloc(sizeof(char*) * 5);
    args[0] = binary;
    args[1] = EXPAND(RECOVERY_API_VERSION);   // defined in Android.mk
    args[2] = malloc(10);
    sprintf(args[2], &quot;%d&quot;, pipefd[1]);
    args[3] = (char*)path;
    args[4] = NULL;

    pid_t pid = fork(); 产生新进程
    if (pid == 0) {
        close(pipefd[0]);
        execv(binary, args); 子进程去执行update_binary去了
        fprintf(stdout, &quot;E:Can't run %s (%s)\n&quot;, binary, strerror(errno));
        _exit(-1);
    }
下面的代码都是父进程的服务代码
    close(pipefd[1]);

    char buffer[1024];
    FILE* from_child = fdopen(pipefd[0], &quot;r&quot;);
    while (fgets(buffer, sizeof(buffer), from_child) != NULL) {
while循环相当于一个服务，执行的都是ui操作
        char* command = strtok(buffer, &quot; \n&quot;);
        if (command == NULL) {
            continue;
        } else if (strcmp(command, &quot;progress&quot;) == 0) {
            char* fraction_s = strtok(NULL, &quot; \n&quot;);
            char* seconds_s = strtok(NULL, &quot; \n&quot;);

            float fraction = strtof(fraction_s, NULL);
            int seconds = strtol(seconds_s, NULL, 10);

            ui_show_progress(fraction * (1-VERIFICATION_PROGRESS_FRACTION),
                             seconds);
        } else if (strcmp(command, &quot;set_progress&quot;) == 0) {
            char* fraction_s = strtok(NULL, &quot; \n&quot;);
            float fraction = strtof(fraction_s, NULL);
            ui_set_progress(fraction);
        } else if (strcmp(command, &quot;ui_print&quot;) == 0) {
            char* str = strtok(NULL, &quot;\n&quot;);
            if (str) {
                ui_print(&quot;%s&quot;, str);
            } else {
                ui_print(&quot;\n&quot;);
            }
        } else {
            LOGE(&quot;unknown command [%s]\n&quot;, command);
        }
    }
    fclose(from_child);

    int status;
    waitpid(pid, &amp;status, 0);
    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
        LOGE(&quot;Error in %s\n(Status %d)\n&quot;, path, WEXITSTATUS(status));
        return INSTALL_ERROR;
    }

    return INSTALL_SUCCESS;
}
</pre>

<p>下面，要看的就是update.zip包中的META-INF/com/google/android/update-binary程序了</p>

<p>程序代码在 bootable/recovery/update/updater.c</p>

<p>整个程序一百多行，不算很多，用到了lex/yacc的东西</p>

<pre class="example">
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;edify/expr.h&quot;
#include &quot;updater.h&quot;
#include &quot;install.h&quot;
#include &quot;minzip/Zip.h&quot;

// Generated by the makefile, this function defines the
// RegisterDeviceExtensions() function, which calls all the
// registration functions for device-specific extensions.
#include &quot;register.inc&quot;

// Where in the package we expect to find the edify script to execute.
// (Note it's &quot;updateR-script&quot;, not the older &quot;update-script&quot;.)
#define SCRIPT_NAME &quot;META-INF/com/google/android/updater-script&quot;
这里定义了脚本文件的位置

int main(int argc, char** argv) {
    // Various things log information to stdout or stderr more or less
    // at random.  The log file makes more sense if buffering is
    // turned off so things appear in the right order.
    setbuf(stdout, NULL);
    setbuf(stderr, NULL);
重定义了标准输出和标准出错

    if (argc != 4) {
        fprintf(stderr, &quot;unexpected number of arguments (%d)\n&quot;, argc);
        return 1;
    }
判断参数

    char* version = argv[1];
    if ((version[0] != '1' &amp;&amp; version[0] != '2' &amp;&amp; version[0] != '3') ||
        version[1] != '\0') {
        // We support version 1, 2, or 3.
        fprintf(stderr, &quot;wrong updater binary API; expected 1, 2, or 3; &quot;
                        &quot;got %s\n&quot;,
                argv[1]);
        return 2;
    }
判断版本号

    // Set up the pipe for sending commands back to the parent process.

    int fd = atoi(argv[2]);
    FILE* cmd_pipe = fdopen(fd, &quot;wb&quot;);
    setlinebuf(cmd_pipe);
获取命令管道，用于图形显示，与父进程IPC

    // Extract the script from the package.

    char* package_data = argv[3];
    ZipArchive za;
    int err;
    err = mzOpenZipArchive(package_data, &amp;za);
    if (err != 0) {
        fprintf(stderr, &quot;failed to open package %s: %s\n&quot;,
                package_data, strerror(err));
        return 3;
    }

    const ZipEntry* script_entry = mzFindZipEntry(&amp;za, SCRIPT_NAME);
    if (script_entry == NULL) {
        fprintf(stderr, &quot;failed to find %s in %s\n&quot;, SCRIPT_NAME, package_data);
        return 4;
    }

    char* script = malloc(script_entry-&gt;uncompLen+1);
    if (!mzReadZipEntry(&amp;za, script_entry, script, script_entry-&gt;uncompLen)) {
        fprintf(stderr, &quot;failed to read script from package\n&quot;);
        return 5;
    }
    script[script_entry-&gt;uncompLen] = '\0';
把脚本内容读入，从压缩包里读入的

    // Configure edify's functions.

    RegisterBuiltins();
    RegisterInstallFunctions();
    RegisterDeviceExtensions();
    FinishRegistration();
注册语句处理函数

    // Parse the script.
下面开始解析脚本，使用了yacc库函数
    Expr* root;
    int error_count = 0;
    yy_scan_string(script);
    int error = yyparse(&amp;root, &amp;error_count);
    if (error != 0 || error_count &gt; 0) {
        fprintf(stderr, &quot;%d parse errors\n&quot;, error_count);
        return 6;
    }

    // Evaluate the parsed script.

    UpdaterInfo updater_info;
    updater_info.cmd_pipe = cmd_pipe;
    updater_info.package_zip = &amp;za;
    updater_info.version = atoi(version);

    State state;
    state.cookie = &amp;updater_info;
    state.script = script;
    state.errmsg = NULL;

    char* result = Evaluate(&amp;state, root);
    if (result == NULL) {
        if (state.errmsg == NULL) {
            fprintf(stderr, &quot;script aborted (no error message)\n&quot;);
            fprintf(cmd_pipe, &quot;ui_print script aborted (no error message)\n&quot;);
        } else {
            fprintf(stderr, &quot;script aborted: %s\n&quot;, state.errmsg);
            char* line = strtok(state.errmsg, &quot;\n&quot;);
            while (line) {
                fprintf(cmd_pipe, &quot;ui_print %s\n&quot;, line);
                line = strtok(NULL, &quot;\n&quot;);
            }
            fprintf(cmd_pipe, &quot;ui_print\n&quot;);
        }
        free(state.errmsg);
        return 7;
    } else {
        fprintf(stderr, &quot;script result was [%s]\n&quot;, result);
        free(result);
    }
解释执行脚本，核心是Evaluate()函数，实现了一个简单的解释器

    if (updater_info.package_zip) {
        mzCloseZipArchive(updater_info.package_zip);
    }
    free(script);

    return 0;
细节隐藏在了Evaluate的callback中
}
</pre>

<p>这个函数在bootable/recovery/edify/expr.c文件中</p>

<pre class="example">
char* Evaluate(State* state, Expr* expr) {
    Value* v = expr-&gt;fn(expr-&gt;name, state, expr-&gt;argc, expr-&gt;argv);
    if (v == NULL) return NULL;
    if (v-&gt;type != VAL_STRING) {
        ErrorAbort(state, &quot;expecting string, got value type %d&quot;, v-&gt;type);
        FreeValue(v);
        return NULL;
    }
    char* result = v-&gt;data;
    free(v);
    return result;
}
</pre>

<p>注意到没有expr-&gt;fn()就把回调函数都执行了</p>

<p>刚才看到过</p>

<pre class="example">
    RegisterBuiltins();
    RegisterInstallFunctions();
    RegisterDeviceExtensions();
    FinishRegistration();
</pre>
这几个函数

<p>先看第一个</p>

<p>也在expr.c中</p>

<pre class="example">
void RegisterBuiltins() {
    RegisterFunction(&quot;ifelse&quot;, IfElseFn);
    RegisterFunction(&quot;abort&quot;, AbortFn);
    RegisterFunction(&quot;assert&quot;, AssertFn);
    RegisterFunction(&quot;concat&quot;, ConcatFn);
    RegisterFunction(&quot;is_substring&quot;, SubstringFn);
    RegisterFunction(&quot;stdout&quot;, StdoutFn);
    RegisterFunction(&quot;sleep&quot;, SleepFn);

    RegisterFunction(&quot;less_than_int&quot;, LessThanIntFn);
    RegisterFunction(&quot;greater_than_int&quot;, GreaterThanIntFn);
}
</pre>

<p>RegisterInstallFunctions函数在updater/install.c中</p>

<pre class="example">
void RegisterInstallFunctions() {
    RegisterFunction(&quot;mount&quot;, MountFn);
    RegisterFunction(&quot;is_mounted&quot;, IsMountedFn);
    RegisterFunction(&quot;unmount&quot;, UnmountFn);
    RegisterFunction(&quot;format&quot;, FormatFn);
    RegisterFunction(&quot;show_progress&quot;, ShowProgressFn);
    RegisterFunction(&quot;set_progress&quot;, SetProgressFn);
    RegisterFunction(&quot;delete&quot;, DeleteFn);
    RegisterFunction(&quot;delete_recursive&quot;, DeleteFn);
    RegisterFunction(&quot;package_extract_dir&quot;, PackageExtractDirFn);
    RegisterFunction(&quot;package_extract_file&quot;, PackageExtractFileFn);
    RegisterFunction(&quot;symlink&quot;, SymlinkFn);
    RegisterFunction(&quot;set_perm&quot;, SetPermFn);
    RegisterFunction(&quot;set_perm_recursive&quot;, SetPermFn);

    RegisterFunction(&quot;getprop&quot;, GetPropFn);
    RegisterFunction(&quot;file_getprop&quot;, FileGetPropFn);
    RegisterFunction(&quot;write_raw_image&quot;, WriteRawImageFn);

    RegisterFunction(&quot;apply_patch&quot;, ApplyPatchFn);
    RegisterFunction(&quot;apply_patch_check&quot;, ApplyPatchCheckFn);
    RegisterFunction(&quot;apply_patch_space&quot;, ApplyPatchSpaceFn);

    RegisterFunction(&quot;read_file&quot;, ReadFileFn);
    RegisterFunction(&quot;sha1_check&quot;, Sha1CheckFn);

    RegisterFunction(&quot;ui_print&quot;, UIPrintFn);

    RegisterFunction(&quot;run_program&quot;, RunProgramFn);
}
</pre>

<p>相当于提供了一个脚本的编写接口，比如ui_print，调用的是UIPrintFn函数</p>

<p>在RunProgramFn函数中，又有一个可以开辟进程执行应用程序的功能，可以用于扩展</p>

<p>到此为止，整个升级流程就大概的分析完了。</p>

<hr />



<hr>
<div id="footer">
  <div id="copyright">
   &copy; 2012 Wizard.Yang
  </div>
  <div id="footdate">
    最后更新 ： 五月  2, 2012
  </div>
</div>

</body>
</html>
